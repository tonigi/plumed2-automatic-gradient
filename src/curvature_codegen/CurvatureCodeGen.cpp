/* +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
   Copyright (c) 2011-2017 The plumed team
   (see the PEOPLE file at the root of the distribution for a list of names)

   See http://www.plumed.org for more information.

   This file is part of plumed, version 2.

   plumed is free software: you can redistribute it and/or modify
   it under the terms of the GNU Lesser General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   plumed is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public License
   along with plumed.  If not, see <http://www.gnu.org/licenses/>.
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ */
#include "core/PlumedMain.h"
#include "colvar/Colvar.h"
#include "colvar/ActionRegister.h"
#include "tools/Pbc.h"
#include "Wrapper.h"

#include <string>
#include <cmath>

using namespace std;

namespace PLMD {
namespace curvature_codegen {

//+PLUMEDOC COLVAR CURVATURE_CODEGEN
/*
Calculate the approximate radius of curvature given three atoms.

The radius of curvature is computed as the radius of the circle
passing through three points given; this should be a fair
approximation of the local curvature for sufficiently smooth polymers
(say, angles between consecutive beads > 90Â°).

The INVERSE flag returns the inverse of the radius. This may be
convenient when biasing, because it removes the singularity (infinite
radius) for straight polymers.

By default the computation takes into account periodic boundary
conditions, unless the NOPBC flag is given.

To compute several local curvatures at once see the
\ref CURVATURE_MULTICOLVAR_CODEGEN multicolvar.



\par Examples

The following input tells PLUMED to print the curvature at
atoms 1,2,3 and its reciprocal.

\verbatim
c1:  CURVATURE_CODEGEN ATOMS=1,2,3
c1i: CURVATURE_CODEGEN ATOMS=1,2,3 INVERSE
PRINT ARG=c1, c1i
\endverbatim





\par Notes

1. Given three points \f$ \mathbf{r}_1 , \mathbf{r}_2 , \mathbf{r}_3 \f$
and their distances \f$ \mathbf{r}_{ij} = \mathbf{r}_i - \mathbf{r}_j
\f$, the radius \f$ r \f$ of their circumcircle is computed with the
sine rule:

\f[
 2 r  = \frac { |\mathbf{r}_{13}| }{\sin \theta_{123}} \qquad \mbox{with} \qquad
 \cos \theta_{123} = \frac{ \mathbf{r}_{12} \cdot \mathbf{r}_{23} }{  |\mathbf{r}_{12} | |\mathbf{r}_{23} | }
\f]


2. In case three beads are connected by two segments of the same length
\f$a\f$, the radius of curvature \f$ r \f$ and the angle \f$ 0 \le
\theta < \pi \f$ at the joint are related through the equation:

\f[
r = \frac{a}{2 \cos (\theta/2) }
\f]


3. With perfectly collinear atoms, the value of the inverse radius is
zero, but the corresponding gradients with respect to the atom
coordinates are undefined. For numerical convenience and analogy with
the \ref ANGLE collective variable, they are taken as zero.


*/
//+ENDPLUMEDOC

class CurvatureCodeGen : public Colvar {
  bool inverse;
  bool pbc;

public:
  static void registerKeywords( Keywords& keys );
  explicit CurvatureCodeGen(const ActionOptions&);
// active methods:
  virtual void calculate();
};

PLUMED_REGISTER_ACTION(CurvatureCodeGen,"CURVATURE_CODEGEN")

void CurvatureCodeGen::registerKeywords( Keywords& keys ) {
  Colvar::registerKeywords( keys );
  keys.add("atoms","ATOMS","the list of three atoms around which to calculate the curvature");
  keys.addFlag("INVERSE",false,"return the inverse of the radius");
  // Why is NOPBC not listed here?
}

CurvatureCodeGen::CurvatureCodeGen(const ActionOptions&ao):
  PLUMED_COLVAR_INIT(ao),
  inverse(false),
  pbc(true)
{
  vector<AtomNumber> atoms;
  parseAtomList("ATOMS",atoms);
  if(atoms.size()!=3)
    error("Number of specified atoms should be 3");

  parseFlag("INVERSE",inverse);

  bool nopbc=!pbc;
  parseFlag("NOPBC",nopbc);
  pbc=!nopbc;

  checkRead();

  log.printf("  between atoms %d %d %d\n",atoms[0].serial(),atoms[1].serial(),atoms[2].serial());
  log.printf("  %susing periodic boundary conditions\n",pbc?"":"not ");
  log.printf("  %sinverting the radius\n",inverse?"":"not ");

  log<<"  Bibliography "
     <<plumed.cite(CURVATURE_CITATION)
     <<"\n";

  addValueWithDerivatives();
  setNotPeriodic();

  requestAtoms(atoms);
}


// calculator
void CurvatureCodeGen::calculate() {

  if(pbc) makeWhole();

  Vector a=getPosition(0);
  Vector b=getPosition(1);
  Vector c=getPosition(2);

  // radius() and radius_grad() are auto-generated by Sympy from
  // symbolic expressions. They may seem very un-optimized, but standard
  // compiler optimizations will collect repeated terms and convert
  // e.g.  pow(x,2) calls to x*x.

  double r=curvature_radius(a[0],a[1],a[2],
                            b[0],b[1],b[2],
                            c[0],c[1],c[2]);

  // Can we avoid computing the gradient if not necessary?
  double ga_d[3], gb_d[3], gc_d[3];
  // Accessing Vector's components directly. Is it valid?
  curvature_radius_grad(a[0],a[1],a[2],
                        b[0],b[1],b[2],
                        c[0],c[1],c[2],
                        ga_d, gb_d, gc_d );

  Vector ga(ga_d[0], ga_d[1], ga_d[2]);
  Vector gb(gb_d[0], gb_d[1], gb_d[2]);
  Vector gc(gc_d[0], gc_d[1], gc_d[2]);

  double value;
  if(!inverse) {
    // We can't do much if r=inf
    value=r;
  } else {
    value=1/r;
    if (value > 0.0) {
      double minus_inv_r2 = -1.0/(r*r);
      ga = minus_inv_r2*ga;
      gb = minus_inv_r2*gb;
      gc = minus_inv_r2*gc;
    } else {
      log.printf("CURVATURE_CODEGEN: radius %f occurred, setting null gradient\n",r);
      Vector v0(0,0,0);
      ga = gb = gc = v0;
    }
  }

  setValue(value);
  setAtomsDerivatives(0,ga);
  setAtomsDerivatives(1,gb);
  setAtomsDerivatives(2,gc);

  setBoxDerivativesNoPbc();	// ??

}

}
}



